\
00000000000	and
00000000001	00600);
00000000010	away
00000000011	heap
00000000100	O_CREAT,
000000001010	will
0000000010110	//heap->items
0000000010111	it
00000000110	check
00000000111	//printf("Post
0000000100	+=
0000000101	printf("The
00000001100	(emptyFileCheck){
00000001101	This
00000001110	O_WRONLY
00000001111	//bzero(str,
00000010	node
0000001100	temp->data
00000011010	heap->size
00000011011	here
00000011100	//First
00000011101	sort;
00000011110	handle->d_name)
00000011111	*/
00000100000	buffer;
00000100001	recursive
00000100010	codeChecked
00000100011	free(temp->data);
000001001	exit(1);
0000010100	opening
0000010101	bzero(str,
00000101100	now
00000101101	/*
0000010111	temp->code
000001100	\t
000001101	struct
00000111	ptr
0000100	1000);
0000101	==
000011	*
00010000	sizeof(char)
000100010	file
0001000110	(readed
0001000111	str,
0001001000	heap->items[heap->numberOfItems
0001001001	return;
000100101	ptr->next;
00010011000	strcat(str,
00010011001	close(fd);
0001001101	0);
0001001110	empty
0001001111	do
000101000	&&
000101001	is
0001010100	temp->next
0001010101	#include
000101011	0){
0001011	int
000110000	in
0001100010000	sizeof(HeapNode)
0001100010001	Karan
0001100010010	Hello
0001100010011	my
0001100010100	malloc(sizeof(HeapNode)
0001100010101	since
0001100010110	((buffer
0001100010111	'\t')
0001100011000	Program\n");
0001100011001	src){
0001100011010	addToTotolList(tokenList);
0001100011011	bzero(heap->items[0].str,
000110001110	freelist(tokenList);
000110001111	deleteNode();
0001100100000	bzero(sort->code,
0001100100001	strcpy(filePath,
0001100100010	type
0001100100011	'.'){
0001100100100	sort->prev
0001100100101	sort->next
0001100100110	sort->code
0001100100111	this
00011001010	'\\';
000110010110	items
000110010111	4096);
000110011000	//Assuming
0001100110010	r
0001100110011	insert(temp);
0001100110100	numOfItems
0001100110101	malloc(sizeof(HuffmanMinHeap));
0001100110110	printMinHeap(){
0001100110111	heapHasMoreThanOne(){
0001100111	temp;
0001101000000	fullRecursive){
0001101000001	file);
0001101000010	copyNode(HeapNode*
0001101000011	DIR
000110100010	fileCompressor
0001101000110	(heapHasMoreThanOne()){
0001101000111	//printMinHeap();
000110100100	heap->items[0].left
000110100101	parentt->occurrences;
000110100110	parent
000110100111	heap->items[0].occurrences
0001101010000	1].right;
0001101010001	itemt->left;
0001101010010	siftDown();
0001101010011	addTokenListToHeap(totalItems);
0001101010100	may
0001101010101	(strlen(ptr->data)
0001101010110	1].occurrences;
0001101010111	1].occurrences
0001101011000	code[0]
0001101011001	//Throw
0001101011010	escape
0001101011011	characters
0001101011100	(item
0001101011101	strcpy(heap->items[0].str,
0001101011110	strlen(str));
0001101011111	1].str);
000110110000	//Throws
0001101100010	Endgame
0001101100011	There
0001101100100	see
0001101100101	<sys/types.h>
000110110011	document
0001101101000	repeats
0001101101001	all:
0001101101010	1].right
0001101101011	sizeofLargestToken();
000110110110	(*fnptr)(char*),
0001101101110	temp[0]
0001101101111	temp[1]
00011011100	(argv[i][1]
0001101110100	//Note
0001101110101	that
000110111011	//char**
000110111100	tokenList;
0001101111010	(r
0001101111011	//Means
0001101111100	parentt
0001101111101	strcpy(temp->data,
0001101111110	ptr2->data
0001101111111	match
000111000000	totalItems->code
0001110000010	name
0001110000011	TO
0001110000100	addToTotolList(node
0001110000101	ptr2){
000111000011	totalItems->next
00011100010	are
000111000110	tempstr
0001110001110	(strcmp(path+(length1
0001110001111	num
000111001000	nextDirectoryName);
000111001001	256
0001110010100	"*.hcz"
0001110010101	-type
000111001011	'\n'
000111001100	huffmanFilePath);
0001110011010	heap->items[min].str);
0001110011011	heap->items[k].occurrences
00011100111	(wrote
000111010000	heap->items[0].right;
000111010001	heap->numberOfItems;
0001110100100	dir;
0001110100101	codebook,
0001110100110	sub
0001110100111	more
0001110101000	printf("IM
0001110101001	temp[i].str,
000111010101	%d\n",
0001110101100	sizeofstring){
0001110101101	1].str,
000111010111	paths
000111011000	1;
0001110110010	Programming
0001110110011	<string.h>
0001110110100	file){
0001110110101	heap->items[min].occurrences
000111011011	totalItems->data
0001110111000	ptr->right;
0001110111001	convertCodebook(codebookFilePath);
0001110111010	happened
0001110111011	filePath,
000111011110	'1'){
0001110111110	"fileCompressor")
0001110111111	(isDirectory(filePath)){
00011110000	filepath);
00011110001	treeptr
000111100100	heap->items[min].occurrences;
000111100101	str[0]
00011110011	open(filepath,
000111101000	node*
000111101001	always
0001111010100	(isFile(filepath)){
0001111010101	printTree(ptr->right);
0001111010110	PROGRAM\n",
0001111010111	recursiveCompress(filePath);
0001111011000	f
0001111011001	siftDown(){
0001111011010	malloc(sizeof(char*)
0001111011011	100);
000111101110	heap->numberOfItems--;
0001111011110	values
0001111011111	while(l
00011111000	[%s]\n",
00011111001	opendir(path);
0001111101000	codeTree->right
0001111101001	list){
0001111101010	(strcmp(str+(length1
0001111101011	buildHuffmanTree();
0001111101100	totalItems,
0001111101101	<stdbool.h>
0001111101110	some
0001111101111	heap->items[l].occurrences;
000111111000	'!';
000111111001	"\t");
0001111110100	recursiveCodeBook(char*
0001111110101	WITH
0001111110110	'd'){
0001111110111	ptr2->next;
0001111111	(buffer
001000000000	file,
0010000000010	filepath
0010000000011	come
00100000001	'\t'){
001000000100	bzero(result,
0010000001010	has
0010000001011	many
001000000110	gonna
0010000001110	codebook
0010000001111	find
0010000010000	listContainsAndUpdates
0010000010001	k;
0010000010010	strlen(second->str)
0010000010011	>=
001000001010	heap->items[0].str);
0010000010110	printf("%s:
0010000010111	third->str
0010000011000	<sys/stat.h>
0010000011001	deleteLatestFilePath(char*
001000001101	temp2
0010000011100	list\n",
0010000011101	(noDuplicatesInList){
0010000011110	not
0010000011111	grown\n");
00100001000	256);
001000010010	heap->numberOfItems){
001000010011	tokens
0010000101000	-o
0010000101001	buildHuffmanTree(){
001000010101	there
0010000101100	minChild
0010000101101	second;
0010000101110	(minChild
0010000101111	(temp
0010000110000	NULL
0010000110001	huffmanString
001000011001	left;
0010000110100	recursiveDecompress(char*
0010000110101	createDecompressedFile(char*
001000011011	break;
0010000111000	left){
0010000111001	third->occurrences
001000011101	heap->items[k].occurrences;
001000011110	isFile(char*
0010000111110	(right
0010000111111	first->str);
001000100	false;
0010001010000	opened\n");
0010001010001	printFileHierachy(directory,
0010001010010	ptr->code,
0010001010011	dest->right
001000101010	ptr->prev;
001000101011	printHuffmanCode(HeapNode*
00100010110	result
001000101110	strlen(nextDirectoryName);
0010001011110	level
0010001011111	strcpy(heap->items[k].str,
00100011	char*
001001000000	empty,
001001000001	list
001001000010	1]
0010010000110	deleteNode(){
0010010000111	bzero(totalItems->data,
0010010001000	while(readed
0010010001001	//Delete
0010010001010	1),
0010010001011	heap->numberOfItems++;
001001000110	if(buffer
001001000111	't';
00100100100	'\n'){
0010010010100	!isFile(filepath)){
0010010010101	applyCodebookToCompress(tokenList);
001001001011	fnptr,
0010010011000	convertCodebook(char*
0010010011001	totalItems->occurrences
0010010011010	writeHuffmanCode();
0010010011011	//FREE
001001001110	recursiveDecompress,
001001001111	handle;
001001010000	less
0010010100010	could
0010010100011	2);
00100101001	ptr->occurrences++;
001001010100	bzero(temp->str,
0010010101010	(realloced
0010010101011	away...
0010010101100	decompressFile(filePath,
0010010101101	realloc(heap->items,
0010010101110	argument:
0010010101111	ERROR\n");
0010010110000	(temp->left
0010010110001	heap->items[k].str);
0010010110010	third->left
0010010110011	first;
001001011010	strlen(str)
0010010110110	writeHuffmanCode(){
0010010110111	open("./HuffmanCodebook",
001001011100	nextDirectoryName){
001001011101	array
0010010111100	(containsHuffmanpPath(filePath)){
0010010111101	Heap\n");
0010010111110	left
0010010111111	255){
001001100000	heap->numberOfItems
0010011000010	heap->items[k].right;
0010011000011	temp->str);
0010011000100	strcpy(heap->items[min].str,
0010011000101	BE
001001100011	read);
00100110010	[%s]
00100110011	typedef
0010011010	for
001001101100	readdir(dir);
0010011011010	(treeptr->left
0010011011011	bzero(code,
0010011011100	//File
0010011011101	strlen(ptr->data);
001001101111	as
0010011100000	convertCodebookToTree(char*
0010011100001	list->data);
0010011100010	strcat(filepath,
0010011100011	itemt->right
0010011100100	USED
0010011100101	strlen(file);
001001110011	argv[i]);
001001110100	codebookfilepath){
0010011101010	codeTree
0010011101011	}node;
001001110110	2*k+1;
0010011101110	//That
0010011101111	means
0010011110000	<fcntl.h>
0010011110001	data;
0010011110010	-f
0010011110011	System
00100111101	given
0010011111000	strcpy(list->code,
0010011111001	list->next;
0010011111010	(strcmp(".git",
0010011111011	string
001001111110	(handle->d_type
0010011111110	deleteLatestFilePath(filepath,
0010011111111	strcmp(".",
00101000000	sizeofstring
001010000010	(strlen(str)
0010100000110	flags
0010100000111	argc;
0010100001000	isTxt(char*
0010100001001	heap->items[min].left;
0010100001010	End
0010100001011	heap->items[k].left
0010100001100	huffmanString+read,
0010100001101	strlen(huffmanString)
001010000111	str[strlen(str)
0010100010000	only
0010100010001	relative
0010100010010	too
0010100010011	populateTokenList(char*
001010001010	100;
0010100010110	printf("Huffman
0010100010111	Codebook
00101000110	malloc(sizeof(HeapNode));
001010001110	result->occurrences
0010100011110	MAXXED
0010100011111	OUT\n");
001010010000	'\\'
001010010001	(ptr->str[0]
0010100100100	ptr->code);
0010100100101	DT_DIR
001010010011	DIR*
0010100101000	".hcz")
0010100101001	itemt->str);
0010100101010	(strcmp(file+(length1
0010100101011	itemt->right;
001010010110	heap->items[0].occurrences;
001010010111	strcat(third->str,
001010011000	numOfItems;
001010011001	temp3;
0010100110100	applyCodebookToCompress(node*
0010100110101	itemt->left
0010100110110	treeptr->left;
0010100110111	'\n'&&
001010011100	{buffer,
0010100111010	furthest
0010100111011	Random
001010011110	temp[i].str
0010100111110	HuffmanMinHeap
0010100111111	heap;
001010100000	compress
0010101000010	size;
0010101000011	heap->size){
00101010001	0
0010101001000	treeptr->right;
0010101001001	strcpy(treeptr->str,
0010101001010	treeptr->left
0010101001011	(treeptr->right
0010101001100	argc,
0010101001101	num){
001010100111	//printf("\n");
0010101010	ptr->next
001010101100	temp4;
0010101011010	process\n",
0010101011011	printTree(HeapNode*
00101010111	decompress
0010101100000	"\n"
0010101100001	(!codeChecked
0010101100010	treeptr->right
0010101100011	prev;
0010101100100	boys
0010101100101	second->str);
001010110011	(length1
001010110100	was
0010101101010	word
0010101101011	printCode(tokenList,
0010101101100	//printlist(totalItems);
0010101101101	HeapNode{
0010101101110	parentt->right
0010101101111	strcmp(handle->d_name,
0010101110000	printf("Invalid
0010101110001	strcpy(temp->code,
0010101110010	needs
0010101110011	(ptr->next
0010101110100	(codeBook){
0010101110101	(totalItems
0010101110110	item
0010101110111	(!isDirectory(filepath)){
001010111100	random
0010101111010	min++;
0010101111011	second->occurrences;
0010101111100	//ONLY
0010101111101	temp[i].occurrences);
0010101111110	Nothung
0010101111111	first->occurrences
0010110000000	createDecompressedFile(filepath,result);
0010110000001	printCode(node*
0010110000010	sort->next;
0010110000011	decompressFile(char*
0010110000100	"hcz");
0010110000101	parentt->right;
0010110000110	sort){
0010110000111	(sort
001011000100	ptr->str[1]
0010110001010	parentt->occurrences
0010110001011	//DIR*
0010110001100	temp->str,
0010110001101	(k
0010110001110	"0");
0010110001111	printHuffmanCode(temp->left,
0010110010000	numberOfItems;
0010110010001	insert(HeapNode*
0010110010010	ptr->data;
0010110010011	src->right;
0010110010100	(list
0010110010101	(handle
0010110010110	!!
0010110010111	IMPORTANT
0010110011000	codeTree->occurrences
0010110011001	getCode(list->data);
0010110011010	codeTree->str
0010110011011	next;
001011001110	result->right
001011001111	itemt->occurrences;
001011010000	recursiveCompress,
001011010001	recursiveBehavior(filePath,
001011010010	tempstr);
0010110100110	successfully
0010110100111	compabilible
0010110101000	COMPRESS
0010110101001	AND
0010110101010	"\\\n");
0010110101011	(214)
001011010110	items;
001011010111	length
0010110110000	min;
0010110110001	(k-1)/2;
0010110110010	p
0010110110011	heap->items[min].right
001011011010	totalItems->prev
001011011011	printf("There
00101101110	tempstr[2]
0010110111100	Code:
0010110111101	HuffmanMinHeap{
0010110111110	'n'){
0010110111111	't'){
0010111000000	fd){
0010111000001	siftUp(){
001011100001	(argv[i][0]
0010111000100	(ptr2
0010111000101	(!listContainsAndUpdates(ptr2->data,
0010111000110	strcpy(huffmanFilePath,
0010111000111	ptr2->occurrences)){
0010111001000	){
0010111001001	printf("Adding
001011100101	sort,
0010111001100	copyNode(items+num,
0010111001101	ptr);
0010111001110	sizeofLargestToken(){
0010111001111	numOfItems++;
001011101000	1){
0010111010010	strcpy(dest->str,
0010111010011	src->str);
00101110101	HeapNode
001011101100	sizeof(char));
001011101101	'n';
001011101110	"/");
0010111011110	'-'){
0010111011111	'b'){
0010111100000	hczfile
0010111100001	strcpy(hczfile,
0010111100010	//Hit
0010111100011	recursiveBehavior(path,
0010111100100	hczfile);
0010111100101	parentt->left
001011110011	(strlen(ptr->str)
001011110100	4;
001011110101	result->left
0010111101100	Error\n");
0010111101101	found
0010111101110	ptr2->occurrences;
0010111101111	ptr2
001011111000	strcpy(str,
0010111110010	nothing
0010111110011	put
0010111110100	".txt")
0010111110101	parentt->left;
001011111011	[%s],
0010111111000	strlen(code)
0010111111001	name:
0010111111010	strcpy(ptr->code,
0010111111011	parentt->str);
0010111111100	l+1;
0010111111101	//char*
0010111111110	ptr->data);
0010111111111	l;
001100000000	result->str
001100000001	heap->size;
00110000001	heap->items
0011000001	directory
0011000010000	//printf("\n",
0011000010001	strcpy(parentt->str,
0011000010010	strlen(code);
0011000010011	freelist(node
00110000101	false);
0011000011000	//printFileHierachy(directory,
0011000011001	heap->items[min].right;
0011000011010	compressFile(filePath,
0011000011011	'1';
00110000111	k
001100010000	str;
0011000100010	printf("Success!
0011000100011	File\n");
0011000100100	buildCodeBook(filePath,
0011000100101	recursive);
0011000100110	heap->items[k].left;
0011000100111	strcpy(huffmanString,
001100010100	recursiveBehavior(char*
001100010101	bzero(temp[i].str,
001100010110	temp4
0011000101110	realloced;
0011000101111	text.
0011000110000	free(result);
0011000110001	convertCodebook(codebookfilepath);
001100011001	wrong
0011000110100	dest->left
0011000110101	Occurrence:
0011000110110	src->left;
0011000110111	ptr->data,
001100011100	temp[i].occurrences
0011000111010	//printHuffmanCode(first,
0011000111011	//printHuffmanCode(second,
001100011110	p;
0011000111110	<dirent.h>
0011000111111	code;
001100100	true;
00110010100	I
0011001010100	flag
0011001010101	ptr2->data);
0011001010110	(!filePathSeen){
0011001010111	bzeros
001100101100	parent){
0011001011010	#
0011001011011	Assignment
0011001011100	printTree(ptr->left);
0011001011101	diles
0011001011110	printf("Scanning
0011001011111	NULL)
001100110000	second
0011001100010	heap->items[r].occurrences;
0011001100011	//exit(1);
001100110010	tokenList
0011001100110	bzero(third->str,
0011001100111	(strlen(first->str)
0011001101000	-delete
0011001101001	codebook:
001100110101	characers
0011001101100	lazy
0011001101101	noDuplicatesInList){
0011001101110	free(code);
0011001101111	getCode(char*
0011001110	ptr;
001100111100	right;
001100111101	strcat(path,
0011001111100	!listContainsAndUpdates(str,
0011001111101	bzero(path+(length1
0011001111110	filePath
0011001111111	recursive){
001101000000	right
001101000001	third
0011010000100	char**
0011010000101	(isDirectory(filepath)){
001101000011	openNewDirectories){
00110100010	ptr){
0011010001100	rm
0011010001101	./HuffmanCodebook
001101000111	".txt"
0011010010000	-g
0011010010001	clean:
0011010010010	stuff
0011010010011	look
0011010010100	<stdio.h>
0011010010101	here...Im
0011010010110	huffmanFilePath
0011010010111	num;
0011010011	of
001101010000	free(tempstr);
0011010100010	siftUp();
0011010100011	}HuffmanTree;
001101010010	temp3
001101010011	dirent
0011010101000	bzero(totalItems->code,
0011010101001	itemt
0011010101010	free(huffmanString);
0011010101011	heap->items[k].right
0011010101100	printHuffmanCode(temp->right,
0011010101101	heap->items[min].left
001101010111	heap->size);
001101011000	handle
0011010110010	sort->occurrences
0011010110011	bzero(sort->data,
00110101101	recursiveBehavior(filepath,
00110101110	'
0011010111100	HuffmanMinHeap;
0011010111101	realloced
0011010111110	(compress){
0011010111111	(decompress){
001101100000	last
0011011000010	appendFilePath(char*
0011011000011	(strcmp(str,
0011011000100	strlen(output)-read);
0011011000101	directory;
0011011000110	str+read,
0011011000111	printHuffmanCode(heap->items,
0011011001	wrote
0011011010000	//intializeMinHeap();
0011011010001	//closedir(directory);
001101101001	'\0'};
00110110101	printf("Error
001101101100	||
0011011011010	sort->data
0011011011011	'c'){
0011011011100	bzero(codeTree->str,
0011011011101	(code
0011011011110	ptr->data)
0011011011111	ptr->occurrences
00110111	NULL;
00111000000	recursive,
0011100000100	dest->occurrences
0011100000101	printlist(node
001110000011	deleteLatestFilePath(path,
0011100001000	output+read,
0011100001001	isDirectory(char*
0011100001010	open(file,
0011100001011	createDecompressFile[%s]\n",
0011100001100	fnptr(path);
0011100001101	printf("[%s]\n",
0011100001110	open,
0011100001111	dest,
0011100010000	src->occurrences;
0011100010001	printf("[%s],
0011100010010	recursiveCompress(char*
0011100010011	(!isDirectory(filepath)
0011100010100	DT_REG
0011100010101	codebookFilePath){
0011100010110	leaf
0011100010111	fullRecursive);
001110001100	'0'){
0011100011010	bad
0011100011011	decompress,
0011100011100	(!isFile(filepath)){
0011100011101	containsHuffmanpPath(char*
0011100011110	//printTree(codeTree);
0011100011111	(num
0011100100000	argv){
0011100100001	1].left
0011100100010	main(int
0011100100011	intializeMinHeap();
001110010010	ptr,
0011100100110	//Because
0011100100111	going
0011100101000	firstCompressor:
0011100101001	gcc
0011100101010	strlen(str);
0011100101011	minheap
0011100101100	1].left;
0011100101101	buildCodeBook(char*
001110010111	recursiveCodeBook,
0011100110	read
0011100111000	free(hczfile);
0011100111001	compressFile(char*
001110011101	path){
00111001111	wrote;
001110100000	strcpy(result->str,
0011101000010	Occurrences:
0011101000011	child
0011101000100	//printHuffmanCode(third,
0011101000101	insert(third);
0011101000110	third->right
0011101000111	printf("\n");
0011101001000	do{
0011101001001	We
001110100101	1));
001110100110	fileCompressor.c
0011101001110	.
0011101001111	-name
0011101010000	(strcmp(ptr->data,
0011101010001	str)
001110101001	(code[i]
0011101010100	recursiveDecompress(filepath);
0011101010101	DECOMPRESS
0011101010110	convertCodebookToTree(codebookfilepath);
0011101010111	dir
001110101100	codeBook
001110101101	filePathSeen
001110101110	totalItems->next;
0011101011110	*=
0011101011111	malloc(sizeofstring
00111011000	with
001110110010	sort
001110110011	code);
0011101101000	ptr->occurrences);
0011101101001	codeTree->left
001110110101	".hcz");
00111011011	handle->d_name);
001110111000	appendFilePath(path,
001110111001	temp2;
0011101110100	intializeMinHeap(){
0011101110101	(!listContainsAndUpdates(tempstr,
0011101110110	failed
0011101110111	filename
001110111100	went
0011101111010	//printf("\t",
0011101111011	temp+read,
001110111110	//printf("The
0011101111110	strcmp("..",
0011101111111	strlen(temp)-read);
001111000000	heap->items[0].right
001111000001	l
00111100001	temp->right
0011110001000	itemt->occurrences
0011110001001	Behavior\n",
0011110001010	EXITING
0011110001011	ptr->left;
001111000110	heap->items[0].left;
0011110001110	'R'){
0011110001111	ptr2->code);
00111100100	am
0011110010100	"HuffmanCodebook")
0011110010101	//grow
0011110010110	listContainsAndUpdates(char*
0011110010111	strlen("HuffmanCodebook");
001111001100	//The
001111001101	temp,
0011110011100	//Free
0011110011101	addTokenListToHeap(node
0011110011110	ptr->occurrences;
0011110011111	strcpy(temp->str,
0011110100000	output){
0011110100001	closedir(dir);
001111010001	50000);
0011110100100	wasn't
0011110100101	openNewDirectories);
0011110100110	code\n");
0011110100111	strcat(hczfile,
0011110101000	'\t'
0011110101001	strcat(code,
0011110101010	(dir
0011110101011	"\\"
0011110101100	were
0011110101101	given,
001111010111	min
0011110110000	<stdlib.h>
0011110110001	}HeapNode;
0011110110010	System-Programming-Assignment-1
0011110110011	1
00111101101	text
001111011100	temp[2]
001111011101	strcpy(temp,
001111011110	(directory
0011110111110	strcpy(itemt->str,
0011110111111	path
00111110	void
00111111	{
010	\n
011000000000	1)){
011000000001	str){
01100000001	fd);
0110000001	temp->prev
0110000010	buffer
0110000011	length2
01100001	0;
011000100	the
0110001010	temp->occurrences
0110001011	+
01100011	!=
011001000	-
0110010010	first
01100100110	(fd
01100100111	write(fd,
01100101000	char
01100101001	i++){
0110010101	str);
011001011	return
0110011000	<
01100110010	true);
01100110011	filepath){
01100110100	length1
01100110101	-1){
01100110110	read(fd,
01100110111	&buffer,
01100111000	heap->items;
01100111001	bzero(temp->data,
01100111010	bzero(temp->code,
01100111011	freelist(totalItems);
011001111	while
01101	=
01110000000	strcpy(ptr->data,
01110000001	i;
01110000010	temp);
0111000001100	//swap
0111000001101	bzero(heap->items[heap->numberOfItems
011100000111	(recursive){
01110000100	(i
01110000101	PROGRAM\n");
01110000110	code
01110000111	>
01110001000	str
01110001001	path);
01110001010	path,
01110001011	free(str);
0111000110	(ptr
01110001110	codeTree;
011100011110	freelist(sort);
011100011111	O_RDONLY);
01110010	else
01110011	malloc(sizeof(char)
011101	}
0111100	if
011110100	temp
011110101	HeapNode*
011110110	bool
01111011100	to
01111011101	emptyFileCheck
0111101111	malloc(sizeof(node));
01111100000	ptr->str);
011111000010	a
011111000011	0)
011111000100	node\n");
011111000101	populateTokenList(filepath,
011111000110	strlen(path);
011111000111	no
01111100100	i
01111100101	EXITTING
011111001100	ptr->code;
011111001101	length2),
01111100111	totalItems
01111101000	be
011111010010	or
011111010011	occurrences;
01111101010	free(temp);
01111101011	tempstr[0]
011111011	NULL){
01111110000	tempstr[1]
01111110001	1);
011111100100	|
011111100101	temp->left
011111100110	filepath,
011111100111	temp->str
01111110100	totalItems;
011111101010	(heap->numberOfItems
011111101011	HuffmanTree
011111101100	//printf("%s",
011111101101	printf("Something
011111101110	result;
011111101111	free(temp->code);
0111111100	sizeofstring);
01111111010	readed
01111111011	strcat(result,
011111111000	strcat(huffmanString,
011111111001	"\n");
01111111101	fd
0111111111	'\0';
1	 

